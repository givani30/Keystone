{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Dependency Management",
        "description": "Set up the project structure, `pyproject.toml` file, and define core vs. optional dependencies as specified in the PRD. This establishes the foundation for all subsequent development.",
        "details": "Create the directory structure outlined in the PRD (`keystone/`, `keystone/core/`, etc.). Initialize a `pyproject.toml` file. Under `[project]`, add `dependencies = [\"pyyaml\", \"jsonschema\"]`. Under `[project.optional-dependencies]`, add `pdf = [\"weasyprint>=60.0\"]` and `dev = [\"pytest\", \"black\", \"mypy\"]`. Create empty `__init__.py` files where necessary to define Python packages.",
        "testStrategy": "Verify the project structure is correct. Run `pip install .` and `pip install .[pdf]` to ensure dependencies are installed correctly. Check that the package is recognized by pip.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Define JSON Schemas for Data and Layout",
        "description": "Define the JSON schemas for validating keybind data files and layout configuration files. These schemas are critical for ensuring data integrity and providing clear validation errors.",
        "details": "Create two files: `keystone/assets/schemas/data_schema.json` and `keystone/assets/schemas/layout_schema.json`. For `data_schema.json`, define fields like `tool`, `version`, and `categories`, ensuring the `keys` property can accept either a string or an array of strings. For `layout_schema.json`, define fields like `title`, `template`, `theme`, `categories`, and `sources` according to the PRD example.",
        "testStrategy": "Manually review the schemas against the PRD examples. Create valid and invalid JSON/YAML example files and prepare them for use in testing the validator module in the next step.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Schema Validator Module",
        "description": "Implement a validation module that uses the `jsonschema` library to validate input data against the defined schemas.",
        "details": "In `keystone/core/validator.py`, create functions like `validate_data(data)` and `validate_layout(data)`. These functions will load the corresponding schema JSON from `keystone/assets/schemas/` and use `jsonschema.validate()` to check the input data. The functions should raise a `jsonschema.ValidationError` on failure.",
        "testStrategy": "Write unit tests using `pytest`. Test the validator functions with valid data files to ensure they pass without errors. Test with invalid data (e.g., missing required fields, wrong data types) to ensure they raise `ValidationError` with informative messages.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement YAML Layout Parser",
        "description": "Create a module responsible for loading and parsing the YAML layout configuration file. This module will orchestrate the data aggregation process.",
        "details": "In `keystone/core/layout_parser.py`, create a function that accepts a path to a YAML file. Use the `pyyaml` library to load and parse the file content. After parsing, use the validator from Task 3 to validate the loaded layout data. This module will initially just parse the layout file; data source loading will be added later.",
        "testStrategy": "Unit test the parser with a valid `layout.yml` file, ensuring the output is a correctly structured Python dictionary. Test with a malformed YAML file to check for `yaml.YAMLError`. Test with a structurally invalid layout to ensure the validator (from Task 3) is called and raises an exception.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Keybind Data Loader",
        "description": "Implement the logic for loading keybind data from tool-specific JSON source files specified in the layout configuration.",
        "details": "In `keystone/core/data_loader.py`, create a function `load_keybind_source(file_path)`. This function will read a JSON file, parse it, and then use the `validator.py` module to validate it against `data_schema.json`. It should return the parsed and validated data as a Python dictionary.",
        "testStrategy": "Unit test the data loader with valid and invalid keybind JSON files. Ensure it correctly parses valid files and raises appropriate validation errors for invalid ones. Test file not found scenarios.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "File Reading and Error Handling",
            "description": "Implement logic to open and read the keybind JSON file from the specified file path. Handle file-related errors such as file not found or permission denied, and raise or log appropriate exceptions.",
            "dependencies": [],
            "details": "Use Python's built-in open() in a try-except block to catch IOError or FileNotFoundError. Ensure that the function provides clear error messages if the file cannot be accessed.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "JSON Parsing and Error Handling",
            "description": "Parse the file content as JSON and handle parsing errors. Ensure that invalid or malformed JSON raises a clear and descriptive error.",
            "dependencies": [
              1
            ],
            "details": "Use json.load() within a try-except block to catch json.JSONDecodeError. Provide informative error messages for invalid JSON syntax, missing data, or data type mismatches.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Schema Validation Using validator.py",
            "description": "Validate the parsed JSON data against the data_schema.json schema using the validator.py module. Handle and report schema validation errors.",
            "dependencies": [
              2
            ],
            "details": "Call the validation function from validator.py, passing the parsed data. If validation fails, raise or log a validation error with details about the schema violation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Unit Test Coverage for Valid, Invalid, and Missing Files",
            "description": "Write unit tests to cover scenarios including valid keybind files, invalid/malformed JSON, schema violations, and missing files.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create test cases for: (a) successfully loading and validating a correct file, (b) handling a missing file, (c) catching JSON parsing errors, and (d) detecting schema validation failures.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Data Merging Logic",
        "description": "Implement the data merging logic that combines keybinds from multiple sources and inline definitions according to the specified priority rules.",
        "details": "Enhance `keystone/core/layout_parser.py`. After parsing the layout file, iterate through the categories and their sources. For each source, call the `data_loader.py` module. Implement the merging logic: a simple override where inline keybinds have the highest priority, followed by keybinds from source files in the order they are listed. The result should be a single, consolidated data structure representing the entire cheatsheet content.",
        "testStrategy": "Write integration tests for the merging logic. Create a layout file with multiple sources and inline keybinds that have conflicting actions. Verify that the final merged data correctly reflects the override rules (inline > first source > second source).",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Iterate and Load All Data Sources",
            "description": "Implement logic to iterate through all specified keybind sources in the layout file and load their data using the data loader module.",
            "dependencies": [],
            "details": "Enhance the layout parser to loop through each category and its associated sources. For each source, call the data loader to parse and validate the JSON file, collecting the resulting data structures for merging.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Override and Priority Rules",
            "description": "Apply the override and priority rules when merging keybind data from multiple sources, ensuring that inline keybinds take precedence, followed by sources in their listed order.",
            "dependencies": [
              1
            ],
            "details": "Design the merging logic so that for each keybind, the value from the highest-priority source (inline > first source > second source, etc.) is used. Handle merging at the keybind level, respecting the specified order.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Merge Inline Keybinds",
            "description": "Integrate inline keybind definitions into the merged data structure, ensuring they override any conflicting keybinds from external sources.",
            "dependencies": [
              2
            ],
            "details": "After merging all external sources, process inline keybinds and update the merged data structure so that any overlapping keys are replaced by the inline definitions.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle Edge Cases in Merging",
            "description": "Implement logic to manage edge cases such as missing keys, conflicting keybinds, or incomplete data during the merge process.",
            "dependencies": [
              3
            ],
            "details": "Detect and handle scenarios where keys are missing from some sources, or where multiple sources define the same keybind with different actions. Decide on error handling or warning strategies for unresolved conflicts.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Write Integration Tests for Merge Scenarios",
            "description": "Develop integration tests that cover various data merging scenarios, including priority overrides, missing keys, and conflicts.",
            "dependencies": [
              4
            ],
            "details": "Create test cases with layout files and source data that exercise all aspects of the merging logic. Verify that the final merged output matches the expected results according to the override and priority rules.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Create and Load Theme and Icon Manifests",
        "description": "Create the manifest files for icons and theme colors, and implement a loader that can parse them.",
        "details": "Create `keystone/assets/icons.json` with a few sample Heroicons as specified. Create `keystone/themes/default.json` with the structure from the PRD (base_styles, card_styles, keybind_styles, color_variants). In `keystone/utils/theme_loader.py`, create a function `load_theme(theme_name)` that reads the corresponding JSON file. Also create a function to load `icons.json`. For now, theme inheritance is not needed.",
        "testStrategy": "Unit test the `theme_loader` to ensure it correctly loads and parses `default.json` and `icons.json`. Verify that accessing keys like `theme['base_styles']['body']` returns the expected string of CSS classes.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement 'Skill Tree' HTML Template",
        "description": "Implement the 'Skill Tree' template, which generates HTML output based on the merged data and a loaded theme.",
        "details": "In `keystone/templates/skill_tree.py`, create a main function `generate_html(data, theme, icons)`. This function will construct the final HTML document as a string. Use f-strings for templating. It should dynamically generate category cards, applying CSS classes from the `theme` dictionary. For example, a card header's class would be `f'{theme[\"card_styles\"][\"card_header\"]} {theme[\"color_variants\"][category_color][\"header\"]}'`. Embed the icon SVG from the `icons` dictionary.",
        "testStrategy": "Write unit tests that pass mock data and theme objects to the `generate_html` function. Assert that the output HTML string contains the expected elements, classes, and content. Perform a visual inspection of the generated HTML file in a browser to ensure it renders correctly.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "HTML Structure Generation",
            "description": "Implement the basic HTML structure for the 'Skill Tree' template using f-strings for templating.",
            "dependencies": [],
            "details": "Create a function in `keystone/templates/skill_tree.py` to generate the HTML structure as a string.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Dynamic Class Assignment from Theme",
            "description": "Dynamically apply CSS classes from the theme dictionary to HTML elements.",
            "dependencies": [
              1
            ],
            "details": "Modify the HTML generation function to include dynamic class assignment based on the theme.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Icon Embedding",
            "description": "Embed icon SVGs from the icons dictionary into the HTML template.",
            "dependencies": [
              2
            ],
            "details": "Add functionality to embed icons into the generated HTML structure.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Unit and Visual Tests with Mock Data",
            "description": "Write unit tests and perform visual inspections to ensure the generated HTML is correct.",
            "dependencies": [
              3
            ],
            "details": "Create unit tests with mock data and visually inspect the generated HTML in a browser.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Basic CLI with `argparse`",
        "description": "Create the main CLI entry point using `argparse`. This initial version will handle taking a layout file and generating an HTML output.",
        "details": "In `keystone/main.py`, use Python's `argparse` module to create a command-line parser. Define a required positional argument for the layout file path and an optional `--output` argument. The main function will call the layout parser (Task 6), the theme loader (Task 7), and the skill tree template (Task 8) to generate the HTML, then write it to the specified output file or a default `output.html`.",
        "testStrategy": "Perform end-to-end testing from the command line. Run `python -m keystone my_layout.yml --output test.html`. Verify that `test.html` is created and contains the expected content. Test edge cases like file not found for the layout file.",
        "priority": "high",
        "dependencies": [
          6,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Argument Parsing Setup",
            "description": "Set up the CLI argument parser using `argparse` to handle required and optional arguments, including layout file path, output file, and format options.",
            "dependencies": [],
            "details": "In `keystone/main.py`, import `argparse`, create an `ArgumentParser`, and define arguments for the layout file (required), output file (optional, default `output.html`), and format (optional, e.g., `html`, `pdf`, `both`). Generate help and usage messages automatically. Exit with appropriate error codes for invalid inputs.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integration with Layout Parser, Theme Loader, and Template",
            "description": "Integrate the argument parser with the layout parser, theme loader, and template modules to generate the final content.",
            "dependencies": [
              1
            ],
            "details": "After parsing arguments, call the layout parser (Task 6) to process the layout file, merge data from sources and inline definitions, and apply `pick_category` filtering if specified. Load the theme (Task 7) and render the content using the skill tree template (Task 8). Handle any module-specific errors gracefully, providing clear user feedback.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Output File Handling",
            "description": "Manage the writing of generated content to the specified output file(s), supporting multiple formats (HTML, PDF, or both).",
            "dependencies": [
              2
            ],
            "details": "Write the rendered HTML to the file specified by `--output` (or default). If `--format` includes `pdf` or `both`, call the PDF generator (Task 10), handling the case where `weasyprint` is not installed. Ensure file operations are atomic where possible and provide clear error messages for permission or filesystem issues.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "End-to-End CLI Tests Including Error Cases",
            "description": "Implement comprehensive end-to-end tests for the CLI, covering success paths and error scenarios.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Write tests that invoke the CLI with various argument combinations, verifying correct file generation and content. Test error cases: missing layout file, invalid file paths, missing dependencies (e.g., `weasyprint`), permission errors, and invalid input formats. Include tests for config file auto-discovery (Task 15) when no layout file is provided. Ensure tests run from different directories and validate both output and error messages.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement PDF Generation with WeasyPrint",
        "description": "Implement the PDF generation capability using `weasyprint`, including graceful error handling if the dependency is not installed.",
        "details": "In `keystone/utils/pdf_generator.py`, create a function `generate_pdf(html_content, output_path)`. Use a `try-except ImportError` block to check for `weasyprint`. If it's not found, print the specified error message to stderr and exit gracefully. If it is found, use `weasyprint.HTML(string=html_content).write_pdf(output_path)`. Update `keystone/main.py` to add a `--format` argument (`html`, `pdf`, `both`) and call this new function when appropriate.",
        "testStrategy": "Test in two environments: one with `weasyprint` installed and one without. With it installed, verify a PDF is correctly generated. Without it, run the command with `--format pdf` and assert that the specific error message is printed and no PDF is created.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate WeasyPrint and Implement Error Handling",
            "description": "Implement PDF generation in keystone/utils/pdf_generator.py using WeasyPrint. Ensure that if WeasyPrint is not installed, the function handles ImportError gracefully by printing a specific error message to stderr and exiting without crashing.",
            "dependencies": [],
            "details": "Create a generate_pdf(html_content, output_path) function. Use a try-except ImportError block to check for WeasyPrint. If missing, print the error and exit. If present, use weasyprint.HTML(string=html_content).write_pdf(output_path).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Extend CLI with Format Selection Argument",
            "description": "Update keystone/main.py to add a --format argument that allows users to select output format: html, pdf, or both. Ensure the CLI calls the PDF generation function when the appropriate format is selected.",
            "dependencies": [
              1
            ],
            "details": "Modify the CLI parser to accept --format with choices 'html', 'pdf', or 'both'. Integrate the generate_pdf function so that PDF output is triggered when requested.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Write Tests for Installed and Missing WeasyPrint Scenarios",
            "description": "Develop tests to verify PDF generation works when WeasyPrint is installed, and that the correct error message is shown and no PDF is created when WeasyPrint is missing.",
            "dependencies": [
              1,
              2
            ],
            "details": "Test with WeasyPrint installed: ensure PDF is generated. Test without WeasyPrint: run with --format pdf, assert error message is printed and no PDF is created.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement Theme System with Inheritance",
        "description": "Enhance the theme loader to support inheritance, allowing custom themes to extend base themes and override specific values.",
        "details": "In `keystone/utils/theme_loader.py`, modify the `load_theme` function. If a theme file contains an `inherits_from` key, first recursively load the base theme. Then, perform a deep merge of the custom theme's values over the base theme's values. The `color_variants` should be merged, not replaced. This allows a user to override just one color, for example.",
        "testStrategy": "Create a `dark.json` theme that inherits from `default.json` and overrides some colors. Write unit tests to load `dark.json` and assert that it contains both the inherited values from `default.json` and its own overridden values.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Detect and Load Base Themes Recursively",
            "description": "Enhance the theme loader to detect if a theme specifies an 'inherits_from' key and recursively load all base themes in the inheritance chain before loading the current theme.",
            "dependencies": [],
            "details": "Modify the load_theme function in keystone/utils/theme_loader.py to check for the 'inherits_from' key in the theme file. If present, recursively load the specified base theme(s) before loading the current theme, ensuring that infinite loops are avoided (e.g., by tracking visited themes).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Deep Merge Theme Dictionaries",
            "description": "Implement logic to deeply merge the dictionaries of the loaded base themes and the current theme, so that nested values are correctly overridden.",
            "dependencies": [
              1
            ],
            "details": "After recursively loading all base themes, perform a deep merge where the current theme's values override those from the base theme(s). Ensure that nested dictionaries are merged rather than replaced, preserving all non-overridden values.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Special Handling for Color Variants",
            "description": "Implement merging logic for the 'color_variants' key so that only specified colors are overridden, and all others are inherited from the base theme.",
            "dependencies": [
              2
            ],
            "details": "When merging the 'color_variants' dictionary, ensure that only the explicitly defined colors in the current theme override the base theme, while all other color variants from the base theme are retained.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Write Unit Tests for Inheritance and Overrides",
            "description": "Create comprehensive unit tests to verify that theme inheritance, deep merging, and color variant overrides work as intended.",
            "dependencies": [
              3
            ],
            "details": "Write tests that load a derived theme (e.g., dark.json) inheriting from a base theme (e.g., default.json), overriding some values and color variants. Assert that the resulting theme contains all inherited values, correctly overridden values, and properly merged color variants.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement 'Reference Card' Template",
        "description": "Implement the 'Reference Card' template, providing a dense, table-based layout as an alternative to the 'Skill Tree'.",
        "details": "Create `keystone/templates/reference_card.py`. Similar to the skill tree template, it will have a `generate_html(data, theme, icons)` function. This function will generate HTML using `<table>` elements to create a dense layout. It should still use the theme dictionary for styling table headers, rows, and key styles to maintain consistency.",
        "testStrategy": "Unit test the template function with mock data. Visually inspect the generated HTML to ensure it's a clean, readable table layout. Update the main CLI (Task 9) to accept a `--template` argument and test generating a cheatsheet with this new template.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "HTML Table Structure Generation",
            "description": "Implement the logic to generate a dense HTML table layout using <table>, <thead>, <tbody>, <tr>, <th>, and <td> elements. Ensure the structure is semantically correct and supports dynamic data rendering.",
            "dependencies": [],
            "details": "Create the core function in reference_card.py that takes structured data and outputs a well-formed HTML table. Use table headers for category or field names and rows for keybind entries. Avoid unnecessary nesting and ensure each row has consistent columns.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Theme-Based Styling Application",
            "description": "Apply theme-based CSS styling to the generated table, including header, row, and cell styles, using the provided theme dictionary for consistency with other templates.",
            "dependencies": [
              1
            ],
            "details": "Integrate CSS rules for table, header, and cell appearance. Use the theme dictionary to set colors, fonts, and spacing. Ensure the table is visually dense but readable, with clear distinction between headers and data rows.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Unit and Visual Tests with Mock Data",
            "description": "Write unit tests for the HTML generation function using mock data, and perform visual inspection of the rendered HTML to ensure correctness and readability.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create test cases that pass sample data and theme settings to the template function. Assert that the output HTML contains the expected structure and styles. Render the HTML in a browser or viewer to visually confirm the table layout and styling.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 13,
        "title": "Enhance CLI for Template and Theme Selection",
        "description": "Expand the CLI to allow users to select templates and themes, and to control output formats more granularly.",
        "details": "In `keystone/main.py`, add `--template` and `--theme` arguments to the `argparse` setup. The `--template` argument should have choices like `skill_tree` and `reference_card`. The CLI logic will dynamically import and call the correct template module based on this flag. The `--theme` flag will be passed to the theme loader.",
        "testStrategy": "Run end-to-end tests from the command line, combining the new flags. For example: `python -m keystone layout.yml --template reference_card --theme dark --format pdf`. Verify the output file uses the correct template and theme styling.",
        "priority": "medium",
        "dependencies": [
          9,
          11,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Argument Parsing for Template and Theme",
            "description": "Extend the CLI's argument parser to accept --template and --theme flags. The --template flag should have choices such as 'skill_tree' and 'reference_card', and --theme should accept a string for the theme name. Ensure these arguments are parsed and validated using argparse.",
            "dependencies": [],
            "details": "Modify keystone/main.py to add the new arguments using argparse's add_argument method. Use the 'choices' parameter for --template to restrict valid options. Ensure the parsed arguments are accessible for subsequent logic.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Enable Dynamic Import and Invocation of Template Modules",
            "description": "Based on the parsed --template argument, dynamically import the corresponding template module and invoke its main function to generate output.",
            "dependencies": [
              1
            ],
            "details": "Use Python's importlib to import the module (e.g., keystone.templates.skill_tree or keystone.templates.reference_card) at runtime. Call the generate_html function from the selected module, passing the required data.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Pass Theme Selection to Theme Loader",
            "description": "Ensure the value from the --theme argument is passed to the theme loader so that the selected theme is applied during output generation.",
            "dependencies": [
              1
            ],
            "details": "Update the CLI logic to pass the theme argument to the theme loading function (e.g., load_theme(theme_name)). Ensure the loaded theme is then provided to the template's generate_html function.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Write End-to-End Tests for Flag Combinations",
            "description": "Develop end-to-end tests that invoke the CLI with various combinations of --template and --theme flags to verify correct output and error handling.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Automate CLI invocations (e.g., using subprocess in pytest) for all valid combinations of template and theme flags. Assert that the output files are generated and styled as expected. Include tests for invalid combinations to ensure proper error messages.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement 'pick_category' Data Filtering",
        "description": "Implement advanced data composition features, allowing users to pick specific categories from source files.",
        "details": "In `keystone/core/layout_parser.py`, enhance the source processing logic. When a source entry in the layout file includes a `pick_category` key (which can be a string or a list of strings), filter the data loaded from that source file to include only the specified categories before merging.",
        "testStrategy": "Create a test layout file that uses `pick_category` to select a subset of categories from a larger data file. Run the generator and assert that the final output contains only the picked categories and not the others from that source file.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Detect and Parse 'pick_category' Key in Source Entries",
            "description": "Enhance the source processing logic in `keystone/core/layout_parser.py` to detect if a `pick_category` key is present in each source entry. Parse its value, supporting both string and list of strings, and prepare the list of categories to be picked from the loaded data.",
            "dependencies": [],
            "details": "Update the parser to check for the presence of the `pick_category` key in each source entry. If found, normalize its value to a list of category names for consistent downstream processing.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Filter Loaded Data According to Parsed Categories",
            "description": "After loading data from a source file, filter its contents to include only the categories specified by the parsed `pick_category` list before merging. Ensure that only the selected categories are retained for further processing.",
            "dependencies": [
              1
            ],
            "details": "Implement the filtering logic using Python techniques such as list comprehensions or the `filter()` function to efficiently select only the desired categories from the loaded data structure.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Integrate Filtering with Merge Logic and Implement Tests",
            "description": "Integrate the category filtering step into the existing data merging logic in `keystone/core/layout_parser.py`. Develop and run tests to verify that only the picked categories are merged and appear in the final output.",
            "dependencies": [
              2
            ],
            "details": "Update the merge pipeline to incorporate the filtered data. Create test cases with layout files specifying `pick_category` and assert that the output contains only the selected categories, ensuring correct integration and behavior.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement Config File Auto-Discovery",
        "description": "Implement auto-discovery of layout configuration files, so the tool can be run from anywhere in a project directory without specifying the file path.",
        "details": "Create `keystone/utils/discovery.py`. Implement a function `find_layout_file()` that checks the current directory (and parent directories up to a certain limit) for `keystone.yml`, `layout.yml`, or `.keystone.yml`. In `keystone/main.py`, if no layout file is provided as an argument, call this discovery function. If no file is found, print an error and exit.",
        "testStrategy": "Create a directory with a `layout.yml` file. `cd` into that directory and run `python -m keystone`. Verify it finds and processes the file. Test from a subdirectory as well. Test in a directory with no config file to ensure the error message is shown.",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Directory Traversal and File Detection Logic",
            "description": "Develop the core logic to traverse the current and parent directories (up to a defined limit) to search for configuration files named 'keystone.yml', 'layout.yml', or '.keystone.yml'. Ensure the logic is robust against edge cases such as symlinks, permission errors, and non-existent directories.",
            "dependencies": [],
            "details": "Create a function (e.g., find_layout_file) in keystone/utils/discovery.py that starts from the current working directory and ascends the directory tree, checking for the presence of any of the target config files at each level. Stop traversal at the filesystem root or after a reasonable number of parent directories. Return the path to the first found file or None if not found.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integrate Auto-Discovery with CLI Argument Handling",
            "description": "Modify the CLI entry point so that if no config file path is provided as an argument, the auto-discovery logic is invoked. If a config file is found, use it; otherwise, print an error and exit.",
            "dependencies": [
              1
            ],
            "details": "In keystone/main.py, update the argument parsing logic to call the discovery function when the layout file argument is missing. Ensure that the CLI behavior is clear and user-friendly, with appropriate error messages if no config file is found.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Write and Run Tests for Discovery in Various Directory Structures",
            "description": "Design and implement tests to verify that the auto-discovery logic works correctly in different directory layouts, including cases where the config file is present in the current directory, a parent directory, or not present at all.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create test directories and files to simulate different scenarios. Write tests that change the working directory and assert that the discovery function finds the correct file or returns an error as expected. Include edge cases such as symlinks, permission issues, and deeply nested directories.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement Advanced CLI Helper Commands",
        "description": "Add helper commands to the CLI for validation, initialization, and listing available resources.",
        "details": "In `keystone/main.py`, add the following arguments: `--validate` (runs validation and exits), `--init` (creates example layout and data files in the current directory), and `--list-themes` (scans the `keystone/themes` directory and prints the names of available themes).",
        "testStrategy": "Test each command individually. Run with `--validate` on valid and invalid files. Run `--init` and check that the example files are created. Run `--list-themes` and verify the output matches the theme files present.",
        "priority": "low",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design CLI Argument Parsing for Helper Commands",
            "description": "Define and implement the CLI argument parsing logic in keystone/main.py to support the new helper commands: --validate, --init, and --list-themes. Ensure each argument is clearly documented and integrated into the CLI help output.",
            "dependencies": [],
            "details": "Use argparse or Typer to add the new arguments. Ensure that running the CLI with --help displays clear usage instructions for each helper command.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Helper Command Logic",
            "description": "Develop the internal logic for each helper command: validation, initialization, and theme listing. Ensure --validate runs validation and exits, --init creates example layout and data files, and --list-themes scans the themes directory and prints available themes.",
            "dependencies": [
              1
            ],
            "details": "Implement the command handlers in keystone/main.py. For --validate, invoke the validation logic and exit. For --init, generate example files in the current directory. For --list-themes, scan keystone/themes and print theme names.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Test and Verify Helper Commands",
            "description": "Individually test each helper command to ensure correct behavior. Validate that --validate works with both valid and invalid files, --init creates the expected files, and --list-themes outputs the correct theme names.",
            "dependencies": [
              2
            ],
            "details": "Create and run test cases for each command. Check file creation, output correctness, and error handling. Update documentation if necessary based on test results.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 17,
        "title": "Implement Icon and Theme Color Reference Validation",
        "description": "Improve validation by checking that `theme_color` and `icon_name` values in the layout file exist in their respective manifests.",
        "details": "In `keystone/core/validator.py`, create a new validation function that runs after the initial schema validation. This function will take the parsed layout, loaded themes, and loaded icons. It will iterate through the layout's categories and check if `category.theme_color` is a valid key in `theme['color_variants']` and `category.icon_name` is a valid key in the icons dictionary. Provide clear error messages for mismatches.",
        "testStrategy": "Create a layout file with an invalid `theme_color` (e.g., 'orange') and another with an invalid `icon_name`. Run the tool and assert that it fails with a specific error message, like 'Error: Theme color \"orange\" not found in theme \"default\".' or 'Error: Icon \"invalid_icon\" not found.'",
        "priority": "medium",
        "dependencies": [
          3,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Add Print-Specific CSS (@media print)",
        "description": "Add print-specific CSS to themes to optimize the generated HTML and PDF for A4 printing.",
        "details": "This is a content task. Modify the theme JSON files (e.g., `default.json`). Add a new key, `print_styles`, containing a string of CSS rules wrapped in an `@media print { ... }` block. This CSS should remove shadows, ensure text is black, control page breaks (`page-break-inside: avoid` on cards), and set appropriate margins. The core generator will embed this CSS block into the `<style>` tag of the HTML output.",
        "testStrategy": "Generate an HTML file. Open it in a browser and use the Print Preview feature. Verify that the print-specific styles are applied (e.g., no box shadows, different layout if specified). Check the generated PDF to ensure it also respects these print styles.",
        "priority": "low",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Responsive CSS for Grid Layouts",
        "description": "Ensure the CSS in the themes produces a responsive layout, particularly for the 'Skill Tree' template.",
        "details": "This is a content task. Review and update the CSS classes in the theme JSON files. For the 'Skill Tree' layout, use CSS Grid (`display: grid`). Define `grid-template-columns` with responsive breakpoints (e.g., `repeat(auto-fill, minmax(300px, 1fr))`) to automatically adjust the number of columns from 1 to 4 based on screen width.",
        "testStrategy": "Generate an HTML file with the 'Skill Tree' template. Open it in a browser and use the developer tools to simulate different screen sizes (mobile, tablet, desktop). Verify that the grid layout adjusts correctly and remains usable at all sizes.",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Create Documentation and Finalize Example Generator",
        "description": "Create comprehensive documentation and example files to guide users. Refine the `--init` command to generate a complete and useful starting project.",
        "details": "Write a `README.md` file explaining all features, CLI options, and the data/layout file formats. Create a set of high-quality example files (`my_workflow.yml`, `zellij.json`, `shell_essentials.json`) that showcase features like multiple sources, category picking, and inline overrides. Update the `--init` command to copy these polished examples into the user's current directory.",
        "testStrategy": "Have a new user follow the `README.md` and use the `--init` command. Verify they can successfully generate a cheatsheet without further instruction. Review the generated documentation and examples for clarity and completeness.",
        "priority": "low",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-18T10:22:32.244Z",
      "updated": "2025-07-18T11:48:13.647Z",
      "description": "Tasks for master context"
    }
  }
}